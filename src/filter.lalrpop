
use ast;

use ast::block_statements as stm;
use ast::{Node, AstLocation, Filter};
use ast::block::{Block, BlockType};
use tok::Location as TokenLocation;
use tok::Tok;
use typed_arena::Arena;
use ast::import::ImportStatement;
use ast::var::{VarDefinition,VarReference};
use ast::expression::{ExpressionValue, ExpressionNode, ExpressionOperation};

#[LALR]
grammar<'ast, 'b>(arena: &'ast Arena<Node<'ast>>, file: &'b str);

extern {
    type Location = TokenLocation;
    type Error = char;

    enum Tok {
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "-" => Tok::Minus,
        "+" => Tok::Plus,
        "*" => Tok::Times,
        "/" => Tok::Div,
        "," => Tok::Comma,
        "\n" => Tok::NewLine,
        "Show" => Tok::Show,
        "Hide" => Tok::Hide,
        "Mixin" => Tok::Mixin,
        "Import" => Tok::Import,
        ">=" => Tok::Gte,
        ">" => Tok::Gt,
        "<=" => Tok::Lte,
        "<" => Tok::Lt,
        "=" => Tok::Eql,
        Num => Tok::Num(<i64>),
        Float => Tok::Float(<f64>),
        QuotedStrLiteral => Tok::StrLiteral(<String>),
        Constant => Tok::Constant(<String>),
        VarIdentifier => Tok::VarIdentifier(<String>)
    }
}

pub Filter : &'ast Node<'ast> = {
    <l:@L> <defs:DefinitionBlock*> <first:ContentBlock> <rest:AnyBlock*> <r:@R> => {
        let mut nodes = defs;
        nodes.push(first);
        nodes.extend(rest);
        arena.alloc(Node::Filter(Filter {
            nodes: nodes,
            transformed_arena: Arena::new(),
            location: AstLocation::new(l, r, file.to_owned())
        }))
    },
    <l:@L> <defs:DefinitionBlock*> <r:@R> => arena.alloc(Node::Filter(
        Filter {
            nodes: defs,
            transformed_arena: Arena::new(),
            location: AstLocation::new(l, r, file.to_owned())
        }
    )),
};

DefinitionBlock : &'ast Node<'ast> = {
    VarDefinition,
    ImportBlock
};

ImportBlock : &'ast Node<'ast> = <l:@L> "Import" <path:RawStrLiteral> <r:@R> "\n" => arena.alloc(Node::Import(
    ImportStatement {
        path: path,
        location: AstLocation::new(l, r, file.to_owned())
    }
));

BlockType : BlockType = {
    "Show" => BlockType::Show,
    "Hide" => BlockType::Hide
};

ContentBlock : &'ast Node<'ast> = {
    <l:@L> <t:BlockType> "\n" <stmts:Statement*> <r:@R> => arena.alloc(Node::Block(
        Block {
            nodes: stmts,
            variant: t,
            location: AstLocation::new(l, r, file.to_owned())
        }
    )),
    <l:@L> "Mixin" <name:Constant> <args:("(" <Comma<VarIdentifier>> ")")?> "\n" <instructions:Statement*> <r:@R> => {
        let params = args
            .unwrap_or(vec![])
            .iter()
            .map(|param_name| ast::mixin::Param { name: param_name.clone(), default: None })
            .collect();
        arena.alloc(Node::Mixin(
            ast::mixin::Mixin{
                name: name,
                parameters: params,
                statements: instructions,
                location: AstLocation::new(l, r, file.to_owned())
            }
        ))
    }
};

AnyBlock : &'ast Node<'ast> = { ImportBlock, ContentBlock };

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

VarDefinition : &'ast Node<'ast>  = {
    <l:@L> <id:VarIdentifier> "=" <v:Value+> <r:@R> "\n" => arena.alloc(Node::VarDefinition(
        VarDefinition {
            identifier: id,
            values: v,
            location: AstLocation::new(l, r, file.to_owned())
        }
    ))
};

VarReference : &'ast Node<'ast> = {
    <l:@L> <ident:VarIdentifier> <r:@R> => arena.alloc(Node::Value(ExpressionValue::Var(
        VarReference {
            identifier: ident,
            location: AstLocation::new(l, r, file.to_owned())
        }
    )))
};

SetValueStmt : &'ast Node<'ast> = {
    <l:@L> <n:Constant> <val:Value+> <r:@R> "\n" => arena.alloc(Node::SetValueStmt(
        stm::SetValueStatement {
            name: n,
            values: val,
            location: AstLocation::new(l, r, file.to_owned())
        }
    ))
};

ConditionStmt : &'ast Node<'ast> = {
    <l:@L> <n: Constant> <cond: Condition> <r:@R> "\n" => arena.alloc(Node::ConditionStmt(
        stm::ConditionStatement {
            name: n,
            condition: cond,
            location: AstLocation::new(l, r, file.to_owned())
        }
    ))
};

MixinCall : &'ast Node<'ast> = {
    <l:@L> "+" <n:Constant> <params:("(" <Comma<Value+>> ")")?> <r:@R> "\n" => arena.alloc(Node::MixinCall(
        ast::mixin::MixinCall {
            name: n,
            parameters: params.unwrap_or(vec![]),
            location: AstLocation::new(l, r, file.to_owned())
        }
    ))
};

Statement : &'ast Node<'ast> = {
    SetValueStmt,
    ConditionStmt,
    MixinCall,
    VarDefinition,
};

Value : &'ast Node<'ast> = {
    ValueExpression,
};

RawStrLiteral : String = {
    QuotedStrLiteral => String::from(<>),
    Constant => String::from(<>),
};

StrLiteral : &'ast Node<'ast> = {
    <l:@L> <s:RawStrLiteral> <r:@R> => arena.alloc(Node::Value(
        ExpressionValue::String(s)
    ))
};

Condition : stm::Condition<'ast> = {
    <op:ComparisonOperator> <v:Value> => stm::Condition { value: v, operator: op }
};

ComparisonOperator : stm::ComparisonOperator = {
    ">=" => stm::ComparisonOperator::Gte,
    ">" =>  stm::ComparisonOperator::Gt,
    "<=" => stm::ComparisonOperator::Lte,
    "<" =>  stm::ComparisonOperator::Lt,
    "=" =>  stm::ComparisonOperator::Eql
};

NumberLiteral : &'ast Node<'ast> = {
    <l:@L> <num:Num> <r:@R> => arena.alloc(Node::Expression(
        ExpressionNode::Val(ExpressionValue::Int(num), AstLocation::new(l, r, file.to_owned()))
    )),
    <l:@L> <num:Float> <r:@R> => arena.alloc(Node::Expression(
        ExpressionNode::Val(ExpressionValue::Decimal(num), AstLocation::new(l, r, file.to_owned()))
    )),
};

ValueExpression : &'ast Node<'ast> = {
    <l:ValueExpression> "+" <r:ValueFactor> => arena.alloc(Node::Expression(
        ExpressionNode::Op(l, ExpressionOperation::Add, r)
    )),
    <l:ValueExpression> "-" <r:ValueFactor> => arena.alloc(Node::Expression(
        ExpressionNode::Op(l, ExpressionOperation::Sub, r)
    )),
    ValueFactor
};

ValueFactor : &'ast Node<'ast> = {
    <l:ValueFactor> "*" <r:ValueTerm> => arena.alloc(Node::Expression(
        ExpressionNode::Op(l, ExpressionOperation::Mul, r)
    )),
    <l:ValueFactor> "/" <r:ValueTerm> => arena.alloc(Node::Expression(
        ExpressionNode::Op(l, ExpressionOperation::Div, r)
    )),
    ValueTerm
};

ValueTerm : &'ast Node<'ast> = {
    VarReference,
    NumberLiteral,
    StrLiteral,
    "(" <ValueExpression> ")" => <>
};

Color: &'ast Node<'ast> = {
    <r:ValueTerm> <g:ValueTerm> <b:ValueTerm> <a:ValueTerm> => arena.alloc(Node::Color(ast::color::Color {
        r: r,
        g: g,
        b: b,
        a: a
    })),
    <left:@L> <r:ValueTerm> <g:ValueTerm> <b:ValueTerm> <right:@R> => arena.alloc(Node::Color(ast::color::Color {
        r: r,
        g: g,
        b: b,
        a: arena.alloc(Node::Expression(
            ExpressionNode::Val(ExpressionValue::Int(255),
            AstLocation::new(left, right, file.to_owned())
        )))
    }))
};
