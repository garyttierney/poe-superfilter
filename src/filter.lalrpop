
use ast;
use std::str::FromStr;
use tok::Location as TokenLocation;
use tok::Tok;

#[LALR]
grammar;

extern {
    type Location = TokenLocation;
    type Error = char;

    enum Tok {
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "-" => Tok::Minus,
        "+" => Tok::Plus,
        "*" => Tok::Times,
        "/" => Tok::Div,
        "\n" => Tok::NewLine,
        "Show" => Tok::Show,
        "Hide" => Tok::Hide,
        ">=" => Tok::Gte,
        ">" => Tok::Gt,
        "<=" => Tok::Lte,
        "<" => Tok::Lt,
        "=" => Tok::Eql,
        Num => Tok::Num(<i32>),
        QuotedStrLiteral => Tok::StrLiteral(<String>),
        Constant => Tok::Constant(<String>)
    }
}

pub Filter: Box<Vec<ast::Block>> = {
    Block* => Box::new(<>)
};

Block: ast::Block = {
    "Show" "\n" <l:Line*> => ast::Block::Show(Box::new(l)),
    "Hide" "\n" <l:Line*> => ast::Block::Hide(Box::new(l)),
};

Line: ast::Instruction = {
    <n:Constant> <v:Value> "\n" => ast::Instruction {
        name: n,
        value: ast::InstructionExpression::Value(v)
    },
    <n:Constant> <c:Condition> "\n" => ast::Instruction {
        name: n,
        value: ast::InstructionExpression::Condition(c)
    }
};

Value: ast::Value = {
    NumExpression+ => ast::Value::Numbers(<>),
    StrLiteral+ => ast::Value::Names(<>)
};

StrLiteral: String = {
    QuotedStrLiteral => String::from(<>),
    Constant => String::from(<>),
};

Condition : ast::Condition = {
    <op:ComparisonOperator> <v:Value> => ast::Condition { value: v, operator: op }
};

ComparisonOperator : ast::ComparisonOperator = {
    ">=" => ast::ComparisonOperator::Gte,
    ">" => ast::ComparisonOperator::Gt,
    "<=" => ast::ComparisonOperator::Lte,
    "<" => ast::ComparisonOperator::Lt,
    "=" => ast::ComparisonOperator::Eq
};

NumExpression : ast::NumberExpression = {
    <l:NumExpression> "+" <r:NumFactor> => ast::NumberExpression::Op(Box::new(l), ast::NumberOperation::Add, Box::new(r)),
    <l:NumExpression> "-" <r:NumFactor> => ast::NumberExpression::Op(Box::new(l), ast::NumberOperation::Sub, Box::new(r)),
    NumFactor
};

NumFactor : ast::NumberExpression = {
    <l:NumFactor> "*" <r:NumTerm> => ast::NumberExpression::Op(Box::new(l), ast::NumberOperation::Mul, Box::new(r)),
    <l:NumFactor> "/" <r:NumTerm> => ast::NumberExpression::Op(Box::new(l), ast::NumberOperation::Div, Box::new(r)),
    NumTerm
};

NumTerm : ast::NumberExpression = {
    Num => ast::NumberExpression::Number(<>),
    "(" <NumExpression> ")" => <>
};

Color: ast::Color = {
    <r:NumExpression> <g:NumExpression> <b:NumExpression> <a:NumExpression> => ast::Color {
        r: r,
        g: g,
        b: b,
        a: a
    },
    <r:NumExpression> <g:NumExpression> <b:NumExpression> => ast::Color {
        r: r,
        g: g,
        b: b,
        a: ast::NumberExpression::Number(255)
    }
};
