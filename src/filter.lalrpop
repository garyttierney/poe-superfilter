
use ast;
use std::str::FromStr;
use tok::Location as TokenLocation;
use tok::Tok;

//#[LALR]
grammar;

extern {
    type Location = TokenLocation;
    type Error = char;

    enum Tok {
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "-" => Tok::Minus,
        "+" => Tok::Plus,
        "*" => Tok::Times,
        "/" => Tok::Div,
        "," => Tok::Comma,
        "\n" => Tok::NewLine,
        "Show" => Tok::Show,
        "Hide" => Tok::Hide,
        "Mixin" => Tok::Mixin,
        "Import" => Tok::Import,
        ">=" => Tok::Gte,
        ">" => Tok::Gt,
        "<=" => Tok::Lte,
        "<" => Tok::Lt,
        "=" => Tok::Eql,
        Num => Tok::Num(<i32>),
        QuotedStrLiteral => Tok::StrLiteral(<String>),
        Constant => Tok::Constant(<String>),
        VarIdentifier => Tok::VarIdentifier(<String>)
    }
}

pub Filter : Box<Vec<ast::Block>> = {
    <def:VarDefinitionBlock?> <blocks:Block*> => {
        let mut blocks = blocks;
        if let Some(b) = def {
            blocks.insert(0, b);
        }
        Box::new(blocks)
    }
};

VarDefinitionBlock : ast::Block = {
    VarDefinition+ => ast::Block::Definitions(<>)
};

Block : ast::Block = {
    "Show" "\n" <FilterInstruction*> => ast::Block::Show(<>),
    "Hide" "\n" <FilterInstruction*> => ast::Block::Hide(<>),
    "Mixin" <name:Constant> <args:("(" <Comma<VarIdentifier>> ")")?> "\n" <instructions:FilterInstruction*> => {
        ast::Block::Mixin {
            name: name,
            parameters: args.unwrap_or(vec![]),
            instructions: instructions,
        }
    }
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

VarDefinition : ast::VarDefinition  = {
    <id:VarIdentifier> "=" <v:Value+> "\n" => ast::VarDefinition { identifier: id, values: v }
};

FilterInstruction : ast::FilterInstruction = {
    <Constant> <Value+> "\n" => ast::FilterInstruction::SetValue(<>),
    <Constant> <Condition> "\n" => ast::FilterInstruction::Condition(<>),
    VarDefinition => ast::FilterInstruction::Var(<>)
};

Value : ast::Value = {
    NumExpression => ast::Value::Num(<>),
    StringExpression => ast::Value::Str(<>),
    VarIdentifier => ast::Value::Var(<>)
};

StringExpression : ast::StringBox = {
    StrLiteral => ast::StringBox::Value(<>),
};

StrLiteral : String = {
    QuotedStrLiteral => String::from(<>),
    Constant => String::from(<>),
};

Condition : ast::Condition = {
    <op:ComparisonOperator> <v:Value> => ast::Condition { value: v, operator: op }
};

ComparisonOperator : ast::ComparisonOperator = {
    ">=" => ast::ComparisonOperator::Gte,
    ">" => ast::ComparisonOperator::Gt,
    "<=" => ast::ComparisonOperator::Lte,
    "<" => ast::ComparisonOperator::Lt,
    "=" => ast::ComparisonOperator::Eq
};

NumExpression : ast::NumberExpression = {
    <l:NumExpression> "+" <r:NumFactor> => ast::NumberExpression::Op(Box::new(l), ast::NumberOperation::Add, Box::new(r)),
    <l:NumExpression> "-" <r:NumFactor> => ast::NumberExpression::Op(Box::new(l), ast::NumberOperation::Sub, Box::new(r)),
    NumFactor
};

NumFactor : ast::NumberExpression = {
    <l:NumFactor> "*" <r:NumTerm> => ast::NumberExpression::Op(Box::new(l), ast::NumberOperation::Mul, Box::new(r)),
    <l:NumFactor> "/" <r:NumTerm> => ast::NumberExpression::Op(Box::new(l), ast::NumberOperation::Div, Box::new(r)),
    NumTerm
};

NumTerm : ast::NumberExpression = {
    Num => ast::NumberExpression::Number(ast::NumberBox::IntValue(<>)),
    "(" <NumExpression> ")" => <>
};

Color: ast::Color = {
    <r:NumExpression> <g:NumExpression> <b:NumExpression> <a:NumExpression> => ast::Color {
        r: r,
        g: g,
        b: b,
        a: a
    },
    <r:NumExpression> <g:NumExpression> <b:NumExpression> => ast::Color {
        r: r,
        g: g,
        b: b,
        a: ast::NumberExpression::Number(ast::NumberBox::IntValue(255))
    }
};
