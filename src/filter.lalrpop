
use ast;
use ast::numbers::NumberExpression;

use ast::block_statements as stm;
use ast::{Arena, Node};
use tok::Location as TokenLocation;
use tok::Tok;

//#[LALR]
grammar<'ast>(arena: &'ast Arena<'ast>);

extern {
    type Location = TokenLocation;
    type Error = char;

    enum Tok {
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "-" => Tok::Minus,
        "+" => Tok::Plus,
        "*" => Tok::Times,
        "/" => Tok::Div,
        "," => Tok::Comma,
        "\n" => Tok::NewLine,
        "Show" => Tok::Show,
        "Hide" => Tok::Hide,
        "Mixin" => Tok::Mixin,
        "Import" => Tok::Import,
        ">=" => Tok::Gte,
        ">" => Tok::Gt,
        "<=" => Tok::Lte,
        "<" => Tok::Lt,
        "=" => Tok::Eql,
        Num => Tok::Num(<i32>),
        QuotedStrLiteral => Tok::StrLiteral(<String>),
        Constant => Tok::Constant(<String>),
        VarIdentifier => Tok::VarIdentifier(<String>)
    }
}

pub Filter : Vec<&'ast Node<'ast>> = {
    <defs:DefinitionBlock*> <first:ContentBlock> <rest:AnyBlock*> => {
        let mut v = defs;
        v.push(first);
        v.extend(rest);
        v
    },
    DefinitionBlock* => <>,
};

DefinitionBlock : &'ast Node<'ast> = {
    VarDefinition => arena.alloc(Node::VarDefinition(<>)),
    ImportBlock
};

ImportBlock : &'ast Node<'ast> = "Import" <StrLiteral> "\n" => arena.alloc(Node::Block(ast::Block::Import(<>)));

ContentBlock : &'ast Node<'ast> = {
    "Show" "\n" <Statement*> => arena.alloc(Node::Block(
        ast::Block::Show(<>.into_iter().map(|e| e as &stm::BlockStatement).collect())
    )),
    "Hide" "\n" <Statement*> => arena.alloc(Node::Block(
        ast::Block::Hide(<>.into_iter().map(|e| e as &stm::BlockStatement).collect())
    )),
    "Mixin" <name:Constant> <args:("(" <Comma<VarIdentifier>> ")")?> "\n" <instructions:Statement*> => {
        let params = args
            .unwrap_or(vec![])
            .iter()
            .map(|param_name| ast::mixin::Param { name: param_name.clone(), default: None })
            .collect();
        arena.alloc(Node::Block(
            ast::Block::Mixin(
                ast::mixin::Mixin{
                    name: name,
                    parameters: params,
                    statements: instructions.into_iter().map(|e| e as &stm::BlockStatement).collect()
                }
            )
        ))
    }
};

AnyBlock : &'ast Node<'ast> = { ImportBlock, ContentBlock };

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

VarDefinition : ast::VarDefinition<'ast>  = {
    <id:VarIdentifier> "=" <v:Value+> "\n" => ast::VarDefinition {
        identifier: id,
        values: v.into_iter().map(|e| e as &ast::Value).collect()
    }
};

SetValueStmt : &'ast Node<'ast> = {
    <n:Constant> <val:Value+> "\n" => arena.alloc(Node::SetValueStmt(
        stm::SetValueStatement {
            name: n,
            values: val.into_iter().map(|e| e as &ast::Value).collect()
        }
    ))
};

ConditionStmt : &'ast Node<'ast> = {
    < n: Constant > < cond: Condition > "\n" => arena.alloc(Node::ConditionStmt(
        stm::ConditionStatement {
            name: n,
            condition: cond
        }
    ))
};

MixinCall : &'ast Node<'ast> = {
    "+" <n:Constant> <params:("(" <Comma<Value>> ")")?> "\n" => arena.alloc(Node::MixinCall(
        ast::mixin::MixinCall {
            name: n,
            parameters: params.unwrap_or(vec![]).into_iter().map(|e| e as &ast::Value).collect()
}
    ))
};

Statement : &'ast Node<'ast> = {
    SetValueStmt,
    ConditionStmt,
    MixinCall,
    VarDefinition => arena.alloc(Node::VarDefinition(<>)),
};

Value : &'ast Node<'ast> = {
    NumExpression,
    StringExpression,
    VarIdentifier => arena.alloc(Node::VarRef(ast::var::VarReference { identifier: <> }))
};

StringExpression : &'ast Node<'ast> = {
    StrLiteral => arena.alloc(Node::StringBox(ast::strings::StringBox::Value(<>))),
};

StrLiteral : String = {
    QuotedStrLiteral => String::from(<>),
    Constant => String::from(<>),
};

Condition : stm::Condition<'ast> = {
    <op:ComparisonOperator> <v:Value> => stm::Condition { value: v, operator: op }
};

ComparisonOperator : stm::ComparisonOperator = {
    ">=" => stm::ComparisonOperator::Gte,
    ">" =>  stm::ComparisonOperator::Gt,
    "<=" => stm::ComparisonOperator::Lte,
    "<" =>  stm::ComparisonOperator::Lt,
    "=" =>  stm::ComparisonOperator::Eql
};

NumExpression : &'ast Node<'ast> = {
    <l:NumExpression> "+" <r:NumFactor> => arena.alloc(Node::NumExpression(
        NumberExpression::Op(l, ast::numbers::NumberOperation::Add, r)
    )),
    <l:NumExpression> "-" <r:NumFactor> => arena.alloc(Node::NumExpression(
        NumberExpression::Op(l, ast::numbers::NumberOperation::Sub, r)
    )),
    NumFactor
};

NumFactor : &'ast Node<'ast> = {
    <l:NumFactor> "*" <r:NumTerm> => arena.alloc(Node::NumExpression(
        NumberExpression::Op(l, ast::numbers::NumberOperation::Mul, r)
    )),
    <l:NumFactor> "/" <r:NumTerm> => arena.alloc(Node::NumExpression(
        NumberExpression::Op(l, ast::numbers::NumberOperation::Div, r)
    )),
    NumTerm
};

NumTerm : &'ast Node<'ast> = {
    Num => arena.alloc(Node::NumExpression(
        NumberExpression::Number(ast::numbers::NumberBox::IntValue(<>))
    )),
    "(" <NumExpression> ")" => <>
};

Color: &'ast Node<'ast> = {
    <r:NumExpression> <g:NumExpression> <b:NumExpression> <a:NumExpression> => arena.alloc(Node::Color(ast::Color {
        r: r,
        g: g,
        b: b,
        a: a
    })),
    <r:NumExpression> <g:NumExpression> <b:NumExpression> => arena.alloc(Node::Color(ast::Color {
        r: r,
        g: g,
        b: b,
        a: arena.alloc(Node::NumExpression(
            NumberExpression::Number(ast::numbers::NumberBox::IntValue(255))
        ))
    }))
};
